<?php

return [
    "Kubernetes lets you fine-tune CPU and memory allocations per container using requests and limits.",
    "Proper scheduling ensures that critical data pipelines aren't starved of resources under load.",
    "Affinity rules can help ensure data-related pods run on the same nodes for cache locality.",
    "Use taints and tolerations to isolate resource-hungry jobs from general workloads.",
    "HPA (Horizontal Pod Autoscaler) is great, but vertical autoscaling is key for batch jobs.",
    "For Spark or Flink on K8s, allocate more memory to driver pods than executors.",
    "Resource requests affect scheduling decisions, while limits cap container usage.",
    "Overcommitting resources in Kubernetes can lead to unpredictable eviction behavior.",
    "Set `QoS` correctly by aligning requests and limits — this affects eviction priority.",
    "Resource metrics via Prometheus can guide capacity planning for data pipelines.",
    "Use Kubernetes Jobs or CronJobs for batch ETL workloads needing resource isolation.",
    "Scheduling can be improved by labeling nodes based on GPU, SSD, or memory types.",
    "Node selectors can restrict pipelines to hardware-optimized nodes (e.g., I/O intensive).",
    "Don’t forget to budget for memory spikes — data transformation can be intensive.",
    "Use the Vertical Pod Autoscaler (VPA) for ML pipelines that evolve over time.",
    "Multi-tenant clusters must strictly enforce resource quotas to prevent abuse.",
    "Use `limitRange` and `resourceQuota` for namespace-level safeguards.",
    "PriorityClasses help ensure mission-critical data jobs get scheduled first.",
    "Scheduling is key for avoiding noisy neighbor effects in shared environments.",
    "Ensure your scheduler supports NUMA-awareness if workloads are CPU intensive.",
    "Kubernetes Resource Policies can help restrict spikey workloads via burst limits.",
    "Node pressure can derail pipelines — use descheduler plugins to rebalance.",
    "Spot node scheduling needs fault-tolerant jobs — retry logic is essential.",
    "Container lifecycle hooks can help with graceful shutdown of long-running tasks.",
    "Use Kubernetes DaemonSets to ensure logs/metrics are collected per node.",
    "Use `topologySpreadConstraints` to distribute pipeline pods across zones or racks.",
    "Try KubeCost or Goldilocks to identify inefficient resource allocation patterns.",
    "Consider deploying an in-cluster scheduler for specialized pipelines (e.g., GPUs).",
    "ElasticSearch or Kafka ingestion pipelines benefit from pinned node placement.",
    "Always benchmark your pipeline container resource usage under peak traffic.",
    "Don’t forget to tune JVM options for Spark containers inside Kubernetes.",
    "Use `kubectl top` and metrics-server to analyze real-time resource usage.",
    "Schedule data-heavy jobs during off-peak hours to avoid contention.",
    "Avoid running pipeline workloads in default namespace — isolate them.",
    "K8s events and logs are vital to diagnosing scheduling bottlenecks.",
    "Consider using kEDA for event-driven pipeline autoscaling.",
    "Make sure to benchmark PVC throughput for I/O-heavy steps.",
    "Tolerate disruption budgets to let maintenance avoid killing jobs.",
    "Use node affinity for cost-aware scheduling on cloud VMs.",
    "Combine namespace-level RBAC and quotas to enforce team boundaries.",
];
